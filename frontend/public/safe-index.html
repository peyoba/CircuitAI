<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CircuitAI - AIç”µè·¯è®¾è®¡å¹³å°</title>
    <link rel="icon" type="image/svg+xml" href="/vite.svg">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', sans-serif;
            background: #f5f5f5;
            overflow-x: hidden;
        }
        
        /* åŠ è½½çŠ¶æ€æ ·å¼ */
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        .fallback-btn {
            padding: 12px 24px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            margin: 5px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .fallback-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }
        
        .error-info {
            color: #ff9999;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px;
            max-width: 500px;
            text-align: center;
            display: none;
        }
        
        /* React åº”ç”¨å®¹å™¨ */
        #root {
            display: none;
        }
        
        #root.loaded {
            display: block;
        }
    </style>
</head>
<body>
    <!-- æ™ºèƒ½åŠ è½½ç•Œé¢ -->
    <div id="loading-container" class="loading-container">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨å¯åŠ¨ CircuitAI...</div>
        <div class="loading-progress" id="loading-progress">åˆå§‹åŒ–åº”ç”¨</div>
        
        <div class="error-info" id="error-info">
            <!-- é”™è¯¯ä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        
        <div id="fallback-options" style="display: none;">
            <a href="/migration-test.html" class="fallback-btn">ğŸ”§ åŠŸèƒ½æµ‹è¯•é¡µ</a>
            <a href="javascript:void(0)" class="fallback-btn" onclick="retryLoad()">ğŸ”„ é‡æ–°å°è¯•</a>
            <a href="javascript:void(0)" class="fallback-btn" onclick="useSimpleMode()">ğŸŒŸ ç®€åŒ–æ¨¡å¼</a>
        </div>
    </div>
    
    <!-- React åº”ç”¨æ ¹å®¹å™¨ -->
    <div id="root"></div>
    
    <script>
        // åŠ è½½çŠ¶æ€ç®¡ç†
        class LoadingManager {
            constructor() {
                this.loadingContainer = document.getElementById('loading-container');
                this.progressElement = document.getElementById('loading-progress');
                this.errorElement = document.getElementById('error-info');
                this.fallbackElement = document.getElementById('fallback-options');
                this.rootElement = document.getElementById('root');
                this.attempts = 0;
                this.maxAttempts = 2;
            }
            
            updateProgress(message) {
                this.progressElement.textContent = message;
                console.log('ğŸ”„ ' + message);
            }
            
            showError(message) {
                this.errorElement.innerHTML = `
                    <strong>âš ï¸ åº”ç”¨åŠ è½½é‡åˆ°é—®é¢˜</strong><br>
                    ${message}<br><br>
                    <small>æ‚¨å¯ä»¥å°è¯•ä»¥ä¸‹é€‰é¡¹ï¼š</small>
                `;
                this.errorElement.style.display = 'block';
                this.fallbackElement.style.display = 'block';
            }
            
            hideLoading() {
                this.loadingContainer.style.display = 'none';
                this.rootElement.classList.add('loaded');
                this.rootElement.style.display = 'block';
            }
            
            async tryLoadReactApp() {
                try {
                    this.attempts++;
                    this.updateProgress(`å°è¯•åŠ è½½ React åº”ç”¨ (${this.attempts}/${this.maxAttempts})`);
                    
                    // æ£€æŸ¥å¿…è¦çš„å…¨å±€å¯¹è±¡
                    if (typeof window.React === 'undefined') {
                        this.updateProgress('åŠ è½½ React åº“...');
                        await this.loadScript('/assets/react-vendor-196c6b5f.js');
                    }
                    
                    // åŠ è½½ä¸»åº”ç”¨
                    this.updateProgress('åŠ è½½ä¸»åº”ç”¨æ¨¡å—...');
                    await this.loadScript('/assets/index-b01d9aee.js');
                    
                    // ç­‰å¾… React åº”ç”¨æ¸²æŸ“
                    this.updateProgress('ç­‰å¾…åº”ç”¨å¯åŠ¨...');
                    await this.waitForReactApp();
                    
                    this.updateProgress('âœ… åº”ç”¨å¯åŠ¨æˆåŠŸï¼');
                    setTimeout(() => this.hideLoading(), 500);
                    
                } catch (error) {
                    console.error('Reactåº”ç”¨åŠ è½½å¤±è´¥:', error);
                    
                    if (this.attempts < this.maxAttempts) {
                        this.updateProgress(`åŠ è½½å¤±è´¥ï¼Œ${2000/1000}ç§’åé‡è¯•...`);
                        setTimeout(() => this.tryLoadReactApp(), 2000);
                    } else {
                        this.showError(`åŠ è½½å¤±è´¥ ${this.attempts} æ¬¡: ${error.message}`);
                    }
                }
            }
            
            loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.type = 'module';
                    script.crossOrigin = 'anonymous';
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`æ— æ³•åŠ è½½è„šæœ¬: ${src}`));
                    document.head.appendChild(script);
                });
            }
            
            waitForReactApp() {
                return new Promise((resolve, reject) => {
                    let checks = 0;
                    const maxChecks = 50; // 5ç§’è¶…æ—¶
                    
                    const checkInterval = setInterval(() => {
                        checks++;
                        
                        // æ£€æŸ¥æ ¹å…ƒç´ æ˜¯å¦æœ‰å†…å®¹
                        const hasContent = this.rootElement.children.length > 0;
                        
                        if (hasContent) {
                            clearInterval(checkInterval);
                            resolve();
                        } else if (checks >= maxChecks) {
                            clearInterval(checkInterval);
                            reject(new Error('React åº”ç”¨å¯åŠ¨è¶…æ—¶'));
                        }
                    }, 100);
                });
            }
        }
        
        // å…¨å±€å‡½æ•°
        window.retryLoad = function() {
            location.reload();
        }
        
        window.useSimpleMode = function() {
            location.href = '/migration-test.html';
        }
        
        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('å…¨å±€é”™è¯¯:', event.error);
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
        });
        
        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', function() {
            const manager = new LoadingManager();
            
            // ç«‹å³å¼€å§‹å°è¯•åŠ è½½
            manager.tryLoadReactApp();
            
            // 10ç§’ç»ˆæè¶…æ—¶ä¿æŠ¤
            setTimeout(() => {
                if (manager.loadingContainer.style.display !== 'none') {
                    manager.showError('åº”ç”¨åŠ è½½è¶…æ—¶ï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢æˆ–ä½¿ç”¨ç®€åŒ–æ¨¡å¼');
                }
            }, 10000);
        });
    </script>
</body>
</html>